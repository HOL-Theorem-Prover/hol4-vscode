{
  "name": "HOL4 Proof script",
  "scopeName": "source.hol4",
  "fileTypes": [".sml"],
  "repository": {

    "todos": {
      "name": "invalid.todo.ml",
      "match": "(TODO|NOTE|XXX|FIXME)"
    },
    "comments": {
      "name": "comment.block.hol",
      "begin": "\\(\\*",
      "end": "\\*\\)",
      "patterns": [
        { "include": "#comments" },
        { "include": "#todos" }
      ]
    },
    "escaped-chars": {
      "name": "constant.character.escape.ml",
      "match": "\\\\\\w"
    },
    "identifier": {
      "name": "entity.name.identifier.ml",
      "match": "[a-zA-Z][a-zA-Z0-9_']*"
    },
    "ml-string": {
      "name": "string.quoted.double.ml",
      "begin": "\"",
      "end": "\"",
      "patterns": [{"include": "#escaped-chars"}]
    },
    "ml-char": {
      "name": "string.quoted.char.ml",
      "begin": "#\"",
      "end": "\"",
      "patterns": [{"include": "#escaped-chars"}]
    },
    "number": {
      "name": "constant.numeric.integer.ml",
      "match": "(?<![+-\\.eE])\\b\\d+\\b(?!\\.)"
    },
    "number-float": {
      "name": "constant.numeric.float.ml",
      "match": "\\b\\d+\\.\\d*([eE][+-]?\\d+)?\\b"
    },
    "ml-keyword": {
      "name": "keyword.other.reserved.ml",
      "match": "\\b(let|local|open|in|end|val|fun|and|struct|sig|infix|infixl|structure|signature|datatype|exception|type)\\b"
    },
    "ml-control": {
      "name": "keyword.control.ml",
      "match": "\\b(if|then|else|raise|handle|case|of|while|before)\\b"
    },
    "ml-operator": {
      "name": "keyword.operator.ml",
      "match": "([\\<\\>=\\_\\+\\-/\\*]|=\\>|\\>=|\\<=|\\^|\\||:|:=|::|!|;)"
    },
    "term-quote-ticks": {
      "begin": "(?<!`)(`+)",
      "end": "(\\1)(?!`)",
      "beginCaptures": {
        "0": { "name": "string.quoted.termquote.hol" }
      },
      "endCaptures": {
        "0": { "name": "string.quoted.termquote.hol" }
      },
      "patterns": [
        { "include": "#hol-term" }
      ]
    },
    "term-quote-unicode-single": {
      "begin": "‘",
      "end": "’",
      "beginCaptures": {
        "0": { "name": "string.quoted.termquote.hol" }
      },
      "endCaptures": {
        "0": { "name": "string.quoted.termquote.hol" }
      },
      "patterns": [
        { "include": "#hol-term" }
      ]
    },
    "term-quote-unicode-double": {
      "begin": "“",
      "end": "”",
      "beginCaptures": {
        "0": { "name": "string.quoted.termquote.hol" }
      },
      "endCaptures": {
        "0": { "name": "string.quoted.termquote.hol" }
      },
      "patterns": [
        { "include": "#hol-term" }
      ]
    },
    "hol-binder": {
      "match": "([∀λ∃\\!\\?]|∃\\!|\\?\\!|some)\\s*([^\\.]+)\\s*(\\.)",
      "captures": {
        "1": { "name": "keyword.other.binder.hol" },
        "2": { "name": "variable.binder.hol" },
        "3": { "name": "keyword.other.binder-end.hol" }
      }
    },
    "hol-connective": {
      "match": "(/\\\\|\\\\/|==>|UNION|DIFF|[¬~=∧≠⇒:\\<>$\\+\\*\\-/\\|])",
      "name": "keyword.operator.connective.hol"
    },
    "hol-special": {
      "match": "\\b(UNIV|IMAGE|FST|SND|LENGTH|MAP|LIST_REL|ALOOKUP|FLOOKUP|OPTREL|REVERSE)\\b",
      "name": "entity.name.function.hol"
    },
    "hol-keywords": {
      "match": "\\b(case|of|if|then|else)\\b",
      "name": "keyword.control.hol"
    },
    "hol-constructor": {
      "match": "\\b[A-Z][\\w_']*\\b",
      "name": "entity.name.type.constructor.hol"
    },
    "hol-constants": {
      "match": "\\b(T|F|EMPTY)\\b",
      "name": "constant.language.various.hol"
    },
    "hol-term": {
      "patterns": [
        { "include": "#comments" },
        { "include": "#ml-string"},
        { "include": "#ml-char"},
        { "include": "#number" },
        { "include": "#number-float" },
        { "include": "#hol-binder" },
        { "include": "#hol-connective" },
        { "include": "#hol-special" },
        { "include": "#hol-constructor" },
        { "include": "#hol-keywords"},
        { "include": "#hol-constants" }
      ]
    },
    "non-standard-ml": {
      "patterns": [
        { "include": "#comments" },
        { "include": "#ml-string" },
        { "include": "#ml-char" },
        { "include": "#number" },
        { "include": "#number-float" },
        { "include": "#ml-keyword" },
        { "include": "#ml-control" },
        { "include": "#ml-operator" },
        { "include": "#term-quote-ticks" },
        { "include": "#term-quote-unicode-single" },
        { "include": "#term-quote-unicode-double" }
      ]
    },
    "rule-label": {
      "match": "^(\\[)([~\\w_']*)(:\\])",
      "captures": {
        "2": {"name": "entity.name.tag.rule-label.hol markup.underline"}
      }
    },
    "definition": {
      "begin": "^(Definition)\\s+([\\w_']*)(\\[([^\\]]*)\\])?(:)",
      "end": "^(Termination|End)",
      "beginCaptures": {
        "1": {"name": "keyword.other.definition.hol"},
        "2": {"name": "entity.name.function.theorem.hol"},
        "4": {"name": "entity.name.tag.attribute.hol"}
      },
      "endCaptures": {
        "0": {"name": "keyword.other.def-end.hol"}
      },
      "patterns": [
        { "include": "#hol-term" }
      ]
    },
    "inductive": {
      "begin": "^((?:Co)?Inductive)\\s+([\\w_']*)(:)",
      "end": "^End",
      "beginCaptures": {
        "1": { "name": "keyword.other.inductive.hol" },
        "2": { "name": "entity.name.function.relation.hol" }
      },
      "endCaptures": {
        "0" : { "name": "keyword.other.def-end.hol" }
      },
      "patterns": [
        { "include": "#hol-term" },
        { "include": "#rule-label" }
      ]
    },
    "theorem-assign": {
      "match": "^(Theorem|Triviality|Type|Overload)\\s+([\\w_']*)(\\[([^\\]]*)\\])?\\s*(=)",
      "captures": {
        "1": {"name": "keyword.other.theorem.hol"},
        "2": {"name": "entity.name.theorem.hol"},
        "4": {"name": "entity.name.tag.attribute.hol"}
      }
    },
    "theorem-proof":
    {
      "begin": "^(Theorem|Triviality)\\s+([\\w_']*)(\\[([^\\]]*)\\])?(:)",
      "end": "^Proof",
      "beginCaptures": {
        "1": {"name": "keyword.other.theorem.hol"},
        "2": {"name": "entity.name.theorem.hol"},
        "4": {"name": "entity.name.tag.attribute.hol"}
      },
      "endCaptures": {
        "0": {"name": "keyword.other.proof.hol"}
      },
      "patterns": [
        { "include": "#hol-term" }
      ]
    },
    "proof-qed":
    {
      "begin": "(?<=^Proof)",
      "end": "^QED",
      "endCaptures": {
        "0": {"name": "keyword.other.qed.hol"}
      },
      "patterns": [
        { "include": "#non-standard-ml" }
      ]
    },
    "tactical": {
      "name": "entity.name.tag.tactical.hol",
      "match": "(\\\\\\\\|THEN[1]?|>>|>-|>~)"
    },
    "cheat": {
      "name": "invalid.tactic.cheat markup.underline",
      "match": "\\bcheat\\b"
    }
  },
  "patterns": [
    { "include": "#theorem-assign" },
    { "include": "#theorem-proof" },
    { "include": "#proof-qed" },
    { "include": "#definition" },
    { "include": "#inductive" },
    { "include": "#non-standard-ml" }
  ]
}
